;; **Problem 1**
;; Given 
(define-struct BTMNode (key value left right))   ;; abbreviated name for BinaryTreeMapNode
;; A (BTMap-of alpha) is either
;; * empty, or
;; * (make-BTMNode key value left right) where
;;   * key is a number;
;;   * value is an alpha;
;;   * left and right are of type (BTMap-of alpha)

;; Generic Template for any function f with primary argument a of type (BTMap of alpha)
#|
 (define (f ... abtm ...)
   (cond [(empty? abtm) ...]
         [(BTMNode
               ... (BTMNode-key abtm)
               ... (BTMNode-value abtm)
               ... (f ... (BTMNode-left abtm) ...) 
               ... (f ... (BTMNode-right abtm) ...) 
               ... ]))
|#


;; An (BSTMap-of alpha) is an (BTMap-of alpha) that is either:
;; * empty, or
;; * a BTMNode (make-BTMNode k v l r) where every key in l is < k and every key in r is > k (implying key values are unique)

;; getBSTMap: number BSTMap -> symbol | false
;; Contract: (getBSTMap n abstm) returns the symbol s in the BTMNode matching n if such a BTMNode exists and false otherwise.
;; Note: Since abstm is ordered as indicated in the definition of the type (BSTMap-of alpha), this search is easy to perform.
;; Examples 
;; <##your test code goes here##>
;; Hint: you may want to define some BSTMap constants to avoid text repetition in your test code

;; Template Instantiation
#|
<##your template code goes here##>
|#

;; Code
;; <##your code for getBSTMap goes here##> (approximately 5 lines)
 
;; Analysis: searching trees vs. searching lists
;;<##your brief (a few lines) discussion comparing the efficiency of the two tasks goes here##>

;; **Problem 2**
;; In this problem, we assume the programmer and the reader are very familiar with the inductive type (list-of alpha), so the associated data definitions, examples, and
;; corresponding natural recursion template are omitted here.

;; For the sake of simplicity, we will represent an ordered pair (a,b) of type (alpha,beta) by the two element list (list a b).  We will call such a pair an alpha-beta-pair.

;; cross: (list-of number) (list-of symbol) -> list-of number-symbol-pair
;; Contract: given a (list-of number) nl and a (list-of symbol) sl, (cross nl sl) returns a list of all possible pairs (n, s) where n is a member of nl and s is a member of sl.
;; Examples:
(check-expect (cross '(1 2) '(a b c)) '((1 a) (1 b) (1 c) (2 a) (2 b) (2 c)))
(check-expect (cross '(1 1) '(a b c)) '((1 a) (1 b) (1 c) (1 a) (1 b) (1 c)))
;; <##you need to include more examples, sufficient to cover your code including base cases and the simple inductive constructions.##>

;; Template Instantiations for cross
;; Hints:
;; 1. The visible function cross performs natural recursion on one argument (say nl).  Introduce a cross-help function that performs natural recursion on the other argument (say sl). 
;; 2. In developing your code, you may want to write and test cross-help first because it can be tested by itself while cross cannot.
;; 3. After giving the template instantiation for cross, show your development of cross-help including type [declaration], contract, and template instantiation.  You may
;;    omit examples since they will be generated by your top level tests if your top-level coverage is good.

;; Template instantiation for cross 
#|
<##your template instantiation for cross which invokes cross-help goes here##>
|#             

;; <##your type [declaration], contract, and template instantiation for cross-help all go here; examples for cross-help are optional##>

;; Code for cross and cross-help
;; Hint: Aim for simplicity; do not worry about using append to concatenate lists a linear number of times.
;;<##Your code for cross and any help functions goes here.##>

;; Problem 3
;; As in Problem 2, we assume the programmer and the reader are very familiar with the inductive type (list-of alpha).  Hence, the associated data definitions, examples, and
;; corresponding natural recursion template are omitted here.  The function that you must write below is discussed in detail in Section 17.6 of the book.  But we expect you to develop
;; a better solution given the following guidance.  In your definition of the merge function, use simple structural case-splitting on both list arguments WITHOUT ANY RECURSION. The second case
;; split is nested inside one arm of the first case split; the ordering of the argument queries does not matter.  For the case where the result cannot be immediately computed without
;; help (both arguments are non-empty), delegate the remainder of the computation to a help function merge-help.  In contrast to the code for the merge function, the code for
;; merge-help function is recursive but its argument types are not identical.  One argument is a non-empty ascending number-list and the other is simply an
;; ascending number-list.  The template for merge-help case splits on whether the possibly empty list is empty or non-empty and performs quasi-structural recursion; it may
;; swap arguments, but the sum of the length of the two arguments strictly decreases in every call).

;; We will use the prefx "(ascending)" in front a (list-of number) parameter in a type to indicate that the parameter must be bound to an ascending [technically
;; non-descending] (list-of number). We will similarly use the prefix "(non-empty)" in front of a (list-of number) parameter to indicate that the parameter must be bound
;; to a non-empty (list-of number).

;; merge: (ascending) (list-of number)  (ascending) (list-of number) -> (ascending) (list-of number)
;; Contract: given two arguments nl1 and nl2 of type (ascending) (list-of number), (merge nl1 nl2) returns the list containing all elements in both lists in ascending order
;; Examples
;; <##your examples for merge and merge-help (assuming you define one) go here##>
;; Template Instantiation for merge
;; <##your template instantiation for merge invoking merge-help goes here##>

;; <##your type [declaration], contract, and template instantiation for merge-help go here; examples are optional.##> 

;; Code
;;<## your code for merge-help and merge goes here; merge-help first ##>

;; Problem 4
;; The Fibonacci function fib is defined by the recursion equation:
;;   fib(n) = fib(n-1) + fib(n-2) for n > 1
;; where fib(0) = fib(1) = 1.
;; The following Racket program computes fib(n) using this definition:

(define (fib n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))

;; <##Your type [declaration], contract, examples, and template instantation for fastFib go here.##>

;; Hints;
;; 1. Your template instantiation for fastFib will be trivial because it will delegate essentially all of the computation to the help function fibHelp with the
;;    following description:

;; fibHelp: nat nat nat -> nat
;; Contract: (fibHelp k fn-k-1 fn-k-2) returns (fib n) provided that fn-k-1 = (fib (- n k 1)), fn-k-2 = (fib (- n k 2))
;; Notes: 1. In Racket (- n k i) returns (n-k)-i.  2. fibHelp is a tail-recursive help function that plays exactly the same role as the obvious loop in an efficient imperative program solving the problem.
;; Examples (included here to show you how fastFib works; they are optional in your submission since fibHelp is a short help function.
;; (check-expect (fibHelp 0 1 1) 2)
;; (check-expect (fibHelp 0 2 1) 3)
;; (check-expect (fibHelp 1 (fib 9) (fib 8)) (fib 11))

;; 2. You need to fully develop fibHelp as a Racket function; some of the code you need to generate appears in template instantiation for fibHelp, namely the recursive call performed by fibHelp.  Examples
;;    for fibHelp are optional but you already have three given above.

;; Code
;; <## your code for fastFib and fibHelp goes here, fibHelp first ##>

;; Problem 5 (Extra Credit)
;; This problem is reasonably hard and time-consuming so if you are interested, don't tackle it until you have done the regular problem very thoroughly.  
